library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_unsigned.all;  -- for simple vector arithmetic

entity de0_cv_top is
  port (
    CLOCK_50 : in  std_logic;                   -- 50 MHz onboard clock
    reset_n  : in  std_logic;                   -- KEY0 on DE0-CV (active low)
    PS2_CLK  : inout std_logic;                 -- PS/2 clock line
    PS2_DAT  : inout std_logic;                 -- PS/2 data line

    VGA_R    : out std_logic_vector(3 downto 0); -- VGA Red[3:0]
    VGA_G    : out std_logic_vector(3 downto 0); -- VGA Green[3:0]
    VGA_B    : out std_logic_vector(3 downto 0); -- VGA Blue[3:0]
    VGA_HS   : out std_logic;                   -- VGA H-sync
    VGA_VS   : out std_logic                    -- VGA V-sync
  );
end entity;

architecture rtl of de0_cv_top is

  -- **clock divider**: 50 MHz â†’ 25 MHz
  signal clk25    : std_logic := '0';
  -- **active-high reset** for mouse (invert the DE0-CV KEY0)
  signal reset_i  : std_logic;

  -- VGA_SYNC signals
  signal pix_row, pix_col      : std_logic_vector(9 downto 0);
  signal vga_r_sig, vga_g_sig, vga_b_sig : std_logic;

  -- mouse outputs
  signal mouse_row, mouse_col  : std_logic_vector(9 downto 0);
  signal left_btn, right_btn   : std_logic;

  -- colour inputs to VGA_SYNC: one red pixel at the cursor
  signal color_r, color_g, color_b : std_logic;

begin

  
  -- Clock divider process
  clk_div : process(CLOCK_50) begin
    if rising_edge(CLOCK_50) then
      clk25 <= not clk25;
    end if;
  end process;

  
  -- Reset logic (KEY0 is active-low, so reset_i is high when KEY0=0)
  reset_i <= not reset_n;

  -- Instantiate the PS/2 mouse controller
  u_mouse : entity work.MOUSE
    port map (
      clock_25Mhz        => clk25,
      reset              => reset_i,
      mouse_data         => PS2_DAT,
      mouse_clk          => PS2_CLK,
      left_button        => left_btn,
      right_button       => right_btn,
      mouse_cursor_row   => mouse_row,
      mouse_cursor_column=> mouse_col
    );

  
  -- Simple colour generator: light up one red pixel at (mouse_row,mouse_col)
  color_gen : process(pix_row, pix_col, mouse_row, mouse_col)
  begin
    if (pix_row = mouse_row and pix_col = mouse_col) then
      color_r <= '1';
    else
      color_r <= '0';
    end if;
    color_g <= '0';
    color_b <= '0';
  end process;

  
  -- Instantiate the VGA sync generator
  u_vga : entity work.VGA_SYNC
    port map (
      clock_25Mhz      => clk25,
      red              => color_r,
      green            => color_g,
      blue             => color_b,
      red_out          => vga_r_sig,
      green_out        => vga_g_sig,
      blue_out         => vga_b_sig,
      horiz_sync_out   => VGA_HS,
      vert_sync_out    => VGA_VS,
      pixel_row        => pix_row,
      pixel_column     => pix_col
    );
  
  -- Expand the single-bit VGA outputs to 4-bit busses
  VGA_R <= (others => vga_r_sig);
  VGA_G <= (others => vga_g_sig);
  VGA_B <= (others => vga_b_sig);

end architecture;



